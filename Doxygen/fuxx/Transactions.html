<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />


<link rel="shortcut icon" type="image/x-icon" href="http://www.arangodb.org/wp-content/themes/triagens/images/favicon.ico">

<link rel="profile" href="http://gmpg.org/xfn/11" />
<link rel="stylesheet" type="text/css" media="all" href="http://www.arangodb.org/wp-content/themes/triagens-child/style.css" />
<link rel="pingback" href="" />


<!-- This site is optimized with the Yoast WordPress SEO plugin v1.4.4 - http://yoast.com/wordpress/seo/ -->
<title>ArangoDB Manual Pages - ArangoDB</title>
<meta name="description" content="ArangoDB Manual Pages"/>
<link rel="canonical" href="http://www.arangodb.org/manualredirector" />
<meta property='og:locale' content='en_US'/>
<meta property='og:title' content='ArangoDB Manual Pages - ArangoDB'/>
<meta property='og:description' content='ArangoDB Manual Pages'/>
<meta property='og:url' content='http://www.arangodb.org/manualredirector'/>
<meta property='og:site_name' content='ArangoDB'/>
<meta property='og:type' content='article'/>
<!-- / Yoast WordPress SEO plugin. -->

<link rel="alternate" type="application/rss+xml" title="ArangoDB &raquo; Feed" href="http://www.arangodb.org/feed" />
<link rel="alternate" type="application/rss+xml" title="ArangoDB &raquo; Comments Feed" href="http://www.arangodb.org/comments/feed" />
<link rel='stylesheet' id='wordpress-popular-posts-css'  href='http://www.arangodb.org/wp-content/plugins/wordpress-popular-posts/style/wpp.css?ver=3.5.1' type='text/css' media='all' />
<link rel='stylesheet' id='wp-syntax-css-css'  href='http://www.arangodb.org/wp-content/plugins/wp-syntax/css/wp-syntax.css?ver=1.0' type='text/css' media='all' />
<script type='text/javascript' src='http://www.arangodb.org/wp-includes/js/jquery/jquery.js?ver=1.8.3'></script>
<script type='text/javascript' src='http://www.arangodb.org/wp-includes/js/comment-reply.min.js?ver=3.5.1'></script>

    <style type="text/css">
    body {
    margin-top: -28px;
    padding-bottom: 28px;
    }
    body.admin-bar #wphead {
       padding-top: 0;
    }
    body.admin-bar #footer {
       padding-bottom: 28px;
    }
<link type="text/css" media="screen" rel="stylesheet" href="http://www.arangodb.org/wp-content/plugins/tweet-blender/css/tweets.css" />

    <style media="print" type="text/css">
      div.faq_answer {display: block!important;}
      p.faq_nav {display: none;}
    </style>


</head>

<body class="page page-id-1410 page-template page-template-onecolumn-page-php">

    <div id="access" role="navigation">
        <div id="nav">
            <a href="http://www.arangodb.org/" title="ArangoDB" id="branding"><img src="/wp-content/themes/triagens/images/logo_arangob_white.gif" width="154" height="34" alt="ArangoDB"></a>
            <div class="menu-header"><ul id="menu-home" class="menu"><li id="menu-item-184" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-184"><a href="http://www.arangodb.org/">Home</a></li>
<li id="menu-item-1345" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1345"><a href="http://www.arangodb.org/try">Try it out</a></li>
<li id="menu-item-279" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-279"><a href="http://www.arangodb.org/documentation">Documentation</a></li>
<li id="menu-item-95" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95"><a href="http://www.arangodb.org/roadmap">Roadmap</a></li>
<li id="menu-item-71" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-71"><a href="http://www.arangodb.org/download">Downloads</a></li>
<li id="menu-item-1299" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1299"><a href="http://www.arangodb.org/api">Drivers</a></li>
<li id="menu-item-156" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-156"><a href="http://www.arangodb.org/blog">Blog</a></li>
</ul></div>            <div class="clear_both"></div>
        </div>
    </div><!-- #access -->

  <div id="surrounding">

    <div id="wrapper" class="hfeed">
	<div id="main">

    <div id="fullsize" class="one-column">
      <div id="content" role="main">



            <div id="post-1410" class="post-1410 page type-page status-publish hentry">
                    <h2 class="entry-title">ArangoDB Manual Pages</h2>

	  <div class="entry-content">

<link id="arangodb.css" type="text/css" href="arangodb.css" rel="stylesheet">
</div>
<div id="manual_search">
<form action="/" id="searchform" method="get" role="search">
  <div><label for="s" class="screen-reader-text">Search for:</label>
    <input type="text" id="s" name="s" value="" />
    <input type="submit" value="Search" id="searchsubmit" />
  </div>
</form>
</div>
<div class="clear_both"></div>
<hr />
<div class="arangodb">
<div>
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Transactions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> <div class="navigate"><a href="UserManualFoxx.html">prev</a> | <a href="UserManual.html">home</a> | <a href="CommandLine.html">next</a></div>  <div class="toc"><ul>
<li><a class="el" href="Transactions.html">Transactions</a><ul>
<li><a class="el" href="Transactions.html#TransactionsIntroduction">Introduction </a></li>
<li><a class="el" href="Transactions.html#TransactionsInvocation">Transaction invocation </a></li>
<li><a class="el" href="Transactions.html#TransactionsParameters">Passing parameters to transactions </a></li>
<li><a class="el" href="Transactions.html#TransactionsDisallowedOperations">Disallowed operations </a></li>
<li><a class="el" href="Transactions.html#TransactionsLocking">Locking and isolation </a></li>
<li><a class="el" href="Transactions.html#TransactionsDurability">Durability </a></li>
<li><a class="el" href="Transactions.html#TransactionsLimitations">Limitations </a> </li>
</ul>
</li>
</ul>
  </div><h2><a class="anchor" id="TransactionsIntroduction"></a>
Introduction </h2>
<p>Starting with version 1.3, ArangoDB provides support for user-definable transactions.</p>
<p>Transactions in ArangoDB are atomic, consistent, isolated, and durable (<em>ACID</em>).</p>
<p>These <em>ACID</em> properties provide the following guarantees:</p>
<ul>
<li>The <em>atomicity</em> priniciple makes transactions either complete in their entirety or have no effect at all.</li>
<li>The <em>consistency</em> principle ensures that no constraints or other invariants will be violated during or after any transaction.</li>
<li>The <em>isolation</em> property will hide the modifications of a transaction from other transactions until the transaction commits.</li>
<li>Finally, the <em>durability</em> proposition makes sure that operations from transactions that have committed will be made persistent. The amount of transaction durability is configurable in ArangoDB, as is the durability on collection level.</li>
</ul>
<h2><a class="anchor" id="TransactionsInvocation"></a>
Transaction invocation </h2>
<p>ArangoDB transactions are different from transactions in SQL.</p>
<p>In SQL, transactions are started with explicit <code>BEGIN</code> or <code>START TRANSACTION</code> command. Following any series of data retrieval or modification operations, an SQL transaction is finished with a <code>COMMIT</code> command, or rolled back with a <code>ROLLBACK</code> command. There may be client/server communication between the start and the commit/rollback of an SQL transaction.</p>
<p>In ArangoDB, a transaction is always a server-side operation, and is executed on the server in one go, without any client interaction. All operations to be executed inside a transaction need to be known by the server when the transaction is started.</p>
<p>There are no individual <code>BEGIN</code>, <code>COMMIT</code> or <code>ROLLBACK</code> transaction commands in ArangoDB. Instead, a transaction in ArangoDB is started by providing a description of the transaction to the <code>db._executeTransaction</code> Javascript function: </p>
<pre class="fragment">db._executeTransaction(description);
</pre><p>This function will then automatically start a transaction, execute all required data retrieval and/or modification operations, and at the end automatically commit the transaction. If an error occurs during transaction execution, the transaction is automatically aborted, and all changes are rolled back.</p>
<h2>Declaration of collections</h2>
<p>All collections which are to participate in a transaction need to be declared beforehand. This is a necessity to ensure proper locking and isolation.</p>
<p>Collections can be used in a transaction in write mode or in read-only mode.</p>
<p>If any data modification operations are to be executed, the collection must be declared for use in write mode. The write mode allows modifying and reading data from the collection during the transaction (i.e. the write mode includes the read mode).</p>
<p>Contrary, using a collection in read-only mode will only allow performing read operations on a collection. Any attempt to write into a collection used in read-only mode will make the transaction fail.</p>
<p>Collections for a transaction are declared by providing them in the <code>collections</code> attribute of the object passed to the <code>_executeTransaction</code> function. The <code>collections</code> attribute has the sub-attributes <code>read</code> and <code>write</code>: </p>
<pre class="fragment">db._executeTransaction({
  collections: {
    write: [ "users", "logins" ],
    read: [ "recommendations" ]
  },
  ...
});
</pre><p><code>read</code> and <code>write</code> are optional attributes, and only need to be specified if the operations inside the transactions demand for it.</p>
<p>The contents of <code>read</code> or <code>write</code> can each be lists with collection names or a single collection name (as a string): </p>
<pre class="fragment">db._executeTransaction({
  collections: {
    write: "users",
    read: "recommendations"
  },
  ...
});
</pre><p>Note that it is currently optional to specify collections for read-only access. Even without specifying them, it is still possible to read from such collections from within a transaction, but with relaxed isolation. Please refer to <a class="el" href="Transactions.html#TransactionsLocking">Locking and isolation </a> for more details.</p>
<h2>Declaration of data modification and retrieval operations</h2>
<p>All data modification and retrieval operations that are to be executed inside the transaction need to be specified in a Javascript function, using the <code>action</code> attribute: </p>
<pre class="fragment">db._executeTransaction({
  collections: {
    write: "users"
  },
  action: function () {
    /* all operations go here */
  }
});
</pre><p>Any valid Javascript code is allowed inside <code>action</code> but the code may only access the collections declared in <code>collections</code>. <code>action</code> may be a Javascript function as shown above, or a string representation of a Javascript function: </p>
<pre class="fragment">db._executeTransaction({
  collections: {
    write: "users"
  },
  action: "function () { /* all operations go here */ }"
});
</pre><p>Please note that any operations specified in <code>action</code> will be executed on the server, in a separate scope. Variables will be bound late. Accessing any Javascript variables defined on the client-side or in some other server context from inside a transaction may not work. Instead, any variables used inside <code>action</code> should be defined inside <code>action</code> itself: </p>
<pre class="fragment">db._executeTransaction({
  collections: {
    write: "users"
  },
  action: function () {
    var db = require(...).db;
    db.users.save({ ... });
  }
});
</pre><p>When the code inside the <code>action</code> attribute is executed, the transaction is already started and all required locks have been acquired. When the code inside the <code>action</code> attribute finishes, the transaction will automatically commit. There is no explicit commit command.</p>
<p>To make a transaction abort and roll back all changes, an exception needs to be thrown and not caught inside the transaction: </p>
<pre class="fragment">db._executeTransaction({
  collections: {
    write: "users"
  },
  action: function () {
    var db = require("internal").db;
    db.users.save({ _key: "hello" });

    /* will abort and roll back the transaction */
    throw "doh!";
  }
});
</pre><p>There is no explicit abort or roll back command.</p>
<p>As mentioned earlier, a transaction will commit automatically when the end of the <code>action</code> function is reached and no exception has been thrown. In this case, the user can return any legal Javascript value from the function: </p>
<pre class="fragment">db._executeTransaction({
  collections: {
    write: "users"
  },
  action: function () {
    var db = require("internal").db;
    db.users.save({ _key: "hello" });

    /* will commit the transaction and return the value "hello" */
    return "hello"; 
  }
});
</pre><h2>Examples</h2>
<p>The first example will write 3 documents into a collection named <code>c1</code>. The <code>c1</code> collection needs to be declared in the <code>write</code> attribute of the <code>collections</code> attribute passed to the <code>executeTransaction</code> function.</p>
<p>The <code>action</code> attribute contains the actual transaction code to be executed. This code contains all data modification operations (3 in this example). </p>
<pre class="fragment">/* setup */
db._create("c1");

db._executeTransaction({
  collections: {
    write: [ "c1" ]
  },
  action: function () {
    var db = require("internal").db;
    db.c1.save({ _key: "key1" });
    db.c1.save({ _key: "key2" });
    db.c1.save({ _key: "key3" });
  }
});

db.c1.count(); /* 3 */
</pre><p>Aborting the transaction by throwing an exception in the <code>action</code> function will revert all changes, so as if the transaction never happened: </p>
<pre class="fragment">/* setup */
db._create("c1");

db._executeTransaction({
  collections: {
    write: [ "c1" ]
  },
  action: function () {
    var db = require("internal").db;
    db.c1.save({ _key: "key1" });
    db.c1.count(); /* 1 */

    db.c1.save({ _key: "key2" });
    db.c1.count(); /* 2 */

    throw "doh!";
  }
});

db.c1.count(); /* 0 */
</pre><p>The automatic rollback is also executed when an internal exception is thrown at some point during transaction execution: </p>
<pre class="fragment">/* setup */
db._create("c1");

db._executeTransaction({
  collections: {
    write: [ "c1" ]
  },
  action: function () {
    var db = require("internal").db;
    db.c1.save({ _key: "key1" });

    /* will throw duplicate a key error, not explicitly requested by the user */
    db.c1.save({ _key: "key1" });  

    /* we'll never get here... */
  }
});

db.c1.count(); /* 0 */
</pre><p>As required by the <em>consistency</em> principle, aborting or rolling back a transaction will also restore secondary indexes to the state at transaction start. The following example using a cap constraint should illustrate that: </p>
<pre class="fragment">/* setup */
db._create("c1");

/* limit the number of documents to 3 */
db.c1.ensureCapConstraint(3); 

/* insert 3 documents */
db.c1.save({ _key: "key1" });
db.c1.save({ _key: "key2" });
db.c1.save({ _key: "key3" });

/* this will push out key1 */
/* we now have these keys: [ "key1", "key2", "key3" ] */
db.c1.save({ _key: "key4" });

db._executeTransaction({
  collections: {
    write: [ "c1" ]
  },
  action: function () {
    var db = require("internal").db;
    /* this will push out key2. we now have keys [ "key3", "key4", "key5" ] */
    db.c1.save({ _key: "key5" }); 

    /* will abort the transaction */
    throw "doh!"
  }
});

/* we now have these keys back: [ "key2", "key3", "key4" ] */
</pre><h2>Cross-collection transactions</h2>
<p>There's also the possibility to run a transaction across multiple collections. In this case, multiple collections need to be declared in the <code>collections</code> attribute, e.g.: </p>
<pre class="fragment">/* setup */
db._create("c1");
db._create("c2");

db._executeTransaction({
  collections: {
    write: [ "c1", "c2" ]
  },
  action: function () {
    var db = require("internal").db;
    db.c1.save({ _key: "key1" });
    db.c2.save({ _key: "key2" });
  }
});

db.c1.count(); /* 1 */
db.c2.count(); /* 1 */
</pre><p>Again, throwing an exception from inside the <code>action</code> function will make the transaction abort and roll back all changes in all collections: </p>
<pre class="fragment">/* setup */
db._create("c1");
db._create("c2");

db._executeTransaction({
  collections: {
    write: [ "c1", "c2" ]
  },
  action: function () {
    var db = require("internal").db;
    for (var i = 0; i &lt; 100; ++i) {
      db.c1.save({ _key: "key" + i });
      db.c2.save({ _key: "key" + i });
    }

    db.c1.count(); /* 100 */
    db.c2.count(); /* 100 */

    /* abort */
    throw "doh!"
  }
});

db.c1.count(); /* 0 */
db.c2.count(); /* 0 */
</pre><h2><a class="anchor" id="TransactionsParameters"></a>
Passing parameters to transactions </h2>
<p>Arbitrary parameters can be passed to transactions by setting the <code>params</code> attribute when declaring the transaction. This feature is handy to re-use the same transaction code for multiple calls but with different parameters.</p>
<p>A basic example: </p>
<pre class="fragment">db._executeTransaction({
  collections: { },
  action: "function (params) { return params[1]; }",
  params: [ 1, 2, 3 ]
});
</pre><p>The above example will return <code>1</code>.</p>
<p>Some example that uses collections: </p>
<pre class="fragment">db._executeTransaction({
  collections: { 
    write: "users",
    read: [ "c1", "c2" ]
  },
  action: "function (params) { var db = require('internal').db; var doc = db.c1.document(params['c1Key']); db.users.save(doc); doc = db.c2.document(params['c2Key']); db.users.save(doc);}", 
  params: { 
    c1Key: "foo", 
    c2Key: "bar" 
  }
});
</pre><h2><a class="anchor" id="TransactionsDisallowedOperations"></a>
Disallowed operations </h2>
<p>Some operations are not allowed inside ArangoDB transactions:</p>
<ul>
<li>creation and deletion of collections (<code>db._create()</code>, <code>db._drop()</code>, <code>db._rename()</code>)</li>
<li>creation and deletion of indexes (<code>db.ensure...Index()</code>, <code>db.dropIndex()</code>)</li>
</ul>
<p>If an attempt is made to carry out any of these operations during a transaction, ArangoDB will abort the transaction with error code <code>1653 (disallowed operation inside transaction)</code>.</p>
<h2><a class="anchor" id="TransactionsLocking"></a>
Locking and isolation </h2>
<p>All collections specified in the <code>collections</code> attribute are locked in the requested mode (read or write) at transaction start. Locking of multiple collections is performed in alphabetical order. When a transaction commits or rolls back, all locks are released in reverse order. The locking order is deterministic to avoid deadlocks.</p>
<p>While locks are held, modifications by other transactions to the collections participating in the transaction are prevented. A transaction will thus see a consistent view of the participating collections' data.</p>
<p>Additionally, a transaction will not be interrupted or interleaved with any other ongoing operations on the same collection. This means each transaction will run in isolation. A transaction should never see uncommitted or rolled back modifications by other transactions. Additionally, reads inside a transaction are repeatable.</p>
<p>Note that the above is true only for all collections that are declared in the <code>collections</code> attribute of the transaction.</p>
<p>There might be situations when declaring all collections a priori is not possible, for example, because further collections are determined by a dynamic AQL query inside the transaction. In this case, it would be impossible to know beforehand which collection to lock, and thus it is legal to not declare collections that will be accessed in the transaction in read-only mode. Accessing a non-declared collection in read-only mode during a transaction will add the collection to the transaction lazily, and fetch data from the collection as usual. However, as the collection ie added lazily, there is no isolation from other concurrent operations or transactions. Reads from such collections are potentially non-repeatable.</p>
<p>Example: </p>
<pre class="fragment">db._executeTransaction({
  collections: { 
    read: "users"
  },
  action: function () {
    /* execute an AQL query that traverses a graph starting at a "users" vertex. 
       it is yet unknown into which other collections the query will traverse */
    db._createStatement({ 
      query: "FOR t IN TRAVERSAL(users, connections, "users/1234", "any", { }) RETURN t"
    }).execute().toArray().forEach(function (d) {
      /* ... */
    });
  }
});
</pre><p>This automatic lazy addition of collections to a transaction also introduces the possibility of deadlocks. Deadlocks may occur if there are concurrent transactions that try to acquire locks on the same collections lazily.</p>
<p>To recover from a deadlock state, ArangoDB will give up waiting for a collection after a configurable amount of time. The wait time can be specified per transaction using the optional<code>lockTimeout</code>attribute. If no value is specified, some default value will be applied.</p>
<p>If ArangoDB was waited at least <code>lockTimeout</code> seconds during lock acquisition, it will give up and rollback the transaction. Note that the <code>lockTimeout</code> is used per lock acquisition in a transaction, and not just once per transaction. There will be at least as many lock acquisition attempts as there are collections used in the transaction. The total lock wait time may thus be much higher than the value of <code>lockTimeout</code>.</p>
<p>To avoid both deadlocks and non-repeatable reads, all collections used in a transaction should always be specified if known in advance.</p>
<h2><a class="anchor" id="TransactionsDurability"></a>
Durability </h2>
<p>Transactions are executed in main memory first until there is either a rollback or a commit. On rollback, no data will be written to disk, but the operations from the transaction will be reversed in memory.</p>
<p>On commit, all modifications done in the transaction will be written to the collection datafiles. These writes will be synchronised to disk if any of the modified collections has the <code>waitForSync</code> property set to <code>true</code>, or if any individual operation in the transaction was executed with the <code>waitForSync</code> attribute. Additionally, transactions that modify data in more than one collection are automatically synchronised to disk. This synchronisation is done to not only ensure durability, but to also ensure consistency in case of a server crash.</p>
<p>That means if you only modify data in a single collection, and that collection has its <code>waitForSync</code> property set to <code>false</code>, the whole transaction will not be synchronised to disk instantly, but with a small delay.</p>
<p>There is thus the potential risk of losing data between the commit of the transaction and the actual (delayed) disk synchronisation. This is the same as writing into collections that have the <code>waitForSync</code> property set to <code>false</code> outside of a transaction. In case of a crash with <code>waitForSync</code> set to false, the operations performed in the transaction will either be visible completely or not at all, depending on whether the delayed synchronisation had kicked in or not.</p>
<p>To ensure durability of transactions on a collection that have the <code>waitForSync</code> property set to <code>false</code>, you can set the <code>waitForSync</code> attribute of the object that is passed to <code>executeTransaction</code>. This will force a synchronisation of the transaction to disk even for collections that have <code>waitForSyncÂ´ set to</code>false`: </p>
<pre class="fragment">db._executeTransaction({
  collections: { 
    write: "users"
  },
  waitForSync: true,
  action: function () { ... }
});
</pre><p>An alternative is to perform an operation with an explicit <code>sync</code> request in a transaction, e.g. </p>
<pre class="fragment">db.users.save({ _key: "1234" }, true); 
</pre><p>In this case, the <code>true</code> value will make the whole transaction be synchronised to disk at the commit.</p>
<p>In any case, ArangoDB will give users the choice of whether or not they want full durability for single collection transactions. Using the delayed synchronisation (i.e. <code>waitForSync</code> with a value of <code>false</code>) will potentially increase throughput and performance of transactions, but will introduce the risk of losing the last committed transactions in the case of a crash.</p>
<p>In contrast, transactions that modify data in more than one collection are automatically synchronised to disk. This comes at the cost of several disk sync For a multi-collection transaction, the call to the <code>_executeTransaction</code> function will only return only after the data of all modified collections has been synchronised to disk and the transaction has been made fully durable. This not only reduces the risk of losing data in case of a crash but also ensures consistency after a restart.</p>
<p>In case of a server crash, any multi-collection transactions that were not yet committed or in preparation to be committed will be rolled back on server restart.</p>
<p>For multi-collection transactions, there will be at least one disk sync operation per modified collection. Multi-collection transactions thus have a potentially higher cost than single collection transactions. There is no configuration to turn off disk synchronisation for multi-collection transactions in ArangoDB. The disk sync speed of the system will thus be the most important factor for the performance of multi-collection transactions.</p>
<h2><a class="anchor" id="TransactionsLimitations"></a>
Limitations </h2>
<p>Transactions in ArangoDB have been designed with particular use cases in mind. They will be mainly useful for short and small data retrieval and/or modification operations.</p>
<p>The implementation is not optimised for very long-running or very voluminuous operations, and may not be usable for these cases.</p>
<p>A major limitation is that a transaction must entirely fit into main memory. This includes all data that is created, updated, or deleted during a transaction, plus management overhead.</p>
<p>Transactions should thus be kept as small as possible, and big operations should be split into multiple smaller transactions if they are too big to fit into one transaction.</p>
<p>Additionally, transactions in ArangoDB cannot be nested, i.e. a transaction must not call any other transaction. If an attempt is made to call a transaction from inside a running transaction, the server will throw error <code>1651 (nested transactions detected</code>).</p>
<p>It is also disallowed to execute user transaction on some of ArangoDB's own system collections. This shouldn't be a problem for regular usage as system collections will not contain user data and there is no need to access them from within a user transaction.</p>
<p>Finally, all collections that may be modified during a transaction must be declared beforehand, i.e. using the <code>collections</code> attribute of the object passed to the <code>_executeTransaction</code> function. If any attempt is made to carry out a data modification operation on a collection that was not declared in the <code>collections</code> attribute, the transaction will be aborted and ArangoDB will throw error <code>1652 unregistered collection used in transaction</code>. It is legal to not declare read-only collections, but this should be avoided if possible to reduce the probability of deadlocks and non-repeatable reads.</p>
<p>Please refer to <a class="el" href="Transactions.html#TransactionsLocking">Locking and isolation </a> for more details. </p>
</div></div><!-- contents -->
</div>


	  </div><!-- .entry-content -->
	</div><!-- #post-## -->


      <div id="comments">


  <p class="nocomments">Comments are closed.</p>



</div><!-- #comments -->


      </div><!-- #content -->
    </div><!-- #container -->

  <div style="clear:both;"></div>
  </div><!-- #main -->



</div><!-- #wrapper -->
</div><!-- #surrounding -->


  <div id="footer" role="contentinfo">
    <div id="colophon">




      <div id="footer-widget-area" role="complementary">

	<div id="first" class="widget-area">
	  <ul class="xoxo">
		<li id="recent-posts-4" class="widget-container widget_recent_entries">	  <h3 class="widget-title">Recent Posts</h3>	<ul>
	  <li>
	<a href="http://www.arangodb.org/2013/05/22/replication-and-sharding-in-arangodb" title="Our plans on replication and sharding in ArangoDB">Our plans on replication and sharding in ArangoDB</a>
	    </li>
	  <li>
	<a href="http://www.arangodb.org/2013/05/14/ideas-and-facts-from-scotland-js-in-edinburgh" title="Ideas and Facts from scotland.js in Edinburgh">Ideas and Facts from scotland.js in Edinburgh</a>
	    </li>
	  <li>
	<a href="http://www.arangodb.org/2013/05/12/arangodb-1-3-0-released" title="ArangoDB 1.3.0 released">ArangoDB 1.3.0 released</a>
	    </li>
	  <li>
	<a href="http://www.arangodb.org/2013/05/06/foxx-screencast-part-2" title="Foxx Screencast: Part 2">Foxx Screencast: Part 2</a>
	    </li>
	</ul>
    </li><li id="text-5" class="widget-container widget_text"><h3 class="widget-title">Documentation</h3>     <div class="textwidget"><ul>
  <li><a href="/quickstart">First step tutorial</a></li>
  <li><a href="/manuals">Manual/documentation (HTML/PDF)</a></li>
  <li><a href="/manuals/arangodb_1.0_shell_reference_card.pdf">ArangoDB Shell Reference Card (HTML/PDF)</a></li>
  <li><a href="/try">Try ArangoDB online</a></li>
  <li><a href="/api">API clients & 3rd party libs</a></li>
        <li><a href="/logos">ArangoDB artwork/logos</a></li>
</ul>
</div>
    </li><li id="text-7" class="widget-container widget_text"><h3 class="widget-title">Social Links</h3>      <div class="textwidget"><ul>
  <li><a href="https://twitter.com/arangodb">ArangoDB on Twitter</a></li>
  <li><a href="https://groups.google.com/group/arangodb">ArangoDB Google Group</a></li>
  <li><a href="http://stackoverflow.com/questions/tagged/arangodb">ArangoDB questions on StackOverflow</a></li>
  <li><a href="https://github.com/triagens/arangodb/issues?state=open">Issue Tracker at Github</a></li>
</ul></div>
    </li><li id="text-6" class="widget-container widget_text"><h3 class="widget-title">Roadmap</h3>	<div class="textwidget"><ul>
  <li><a href="/roadmap/#v1.4">Backlog for Version 1.4</a></li>
  <li><a href="/roadmap/#v1.x">Backlog for Version 1.x</a></li>
</ul></div>
    </li>	  </ul>
	</div><!-- #first .widget-area -->




      </div><!-- #footer-widget-area -->


<!-- #site-generator -->

    </div><!-- #colophon -->

        <div class="copy">
            Copyright 2013 ArangoDB | <a href="/imprint">Imprint</a>
        </div>

  </div><!-- #footer -->

</body>
</html>